Removing Numbers from Array

Index Initialization: The register ecx was reset to 0 to keep track of the number of valid elements in the target array.

Processing Loop: A loop was used to iterate through each element of the input array. The esi register holds the address of the input array, and ebx stores the count of remaining elements to process.

Odd Number Check: For each element, the instruction test eax, 1 was used to check if the least significant bit (LSB) is 1, indicating an odd number. If the number was odd, the loop skipped to the next element using a jump (jnz next).

Power of Two Check: If the number was even, 1 was subtracted from it (sub eax, 1), then an and operation was performed between the original number and this result. If the result was 0, the number is a power of two (since powers of two have only a single bit set). In this case, the loop advanced to the next number using jz next.

Storing Valid Numbers: Numbers that were neither odd nor powers of two were copied into the target array using mov [edi + ecx * 4], eax. The index counter ecx was then incremented to advance to the next position in the destination array.

Finalization: After processing all elements, the number of valid elements stored in ecx was written to the memory location pointed to by edx (mov [edx], ecx).

Summary: This function processed the input array, removing all odd numbers and powers of two, returning the count of valid elements.

Validating Events

Iterating Over Events: A loop processed each event's data via the ebx register. Initially, the valid field for each event was set to 0, assuming it was invalid until proven otherwise.

Year Validation: Compared the eventâ€™s year with the range 1990 to 2030. Events outside this range were skipped.

Month Validation: Checked if the month was between 1 and 12. Invalid months caused the event to be skipped.

Day Validation: Accessed the day and month fields from the event structure. The month value was extended (movzx) to correctly reference the number of valid days in that month from a days array. The day was verified to be within the allowed range for that month. Invalid days caused skipping.

Setting Validity: If year, month, and day were valid, the valid flag was set to 1.

Moving to Next Event: After processing, the pointer advanced to the next event by adding event_size to ebx. The loop continued until all events were processed.

Bubble Sorting Events

Known Values:

ebx: pointer to the events array

ecx: length of the array (n)

Preparation: Decremented ecx by 1 to adjust the number of required iterations for the bubble sort, which processes elements from 0 to n-1.

Comparison Loops: Two loops were implemented:

Outer loop (do_loop) repeats until no swaps are needed.

Inner loop (for_loop) compares adjacent pairs of events and swaps them if out of order.

Flags and Indexing: At the start of each outer loop iteration, dl was set to 0 to indicate no swaps yet; edi tracked the current event index.

Comparison Criteria:

Validity: Valid events are ordered before invalid ones. If the current event is invalid and the next is valid, swap.

Year: If validity flags are equal, events with smaller years come first.

Month and Day: If years match, compare months; if months also match, compare days.

Name: If all above equal, event names were compared byte-by-byte and swapped if necessary.

Field Swapping: When a swap was necessary, the relevant fields (valid, day, month, year, and name) were exchanged using mov instructions. Swapping text fields (name) required bit-by-bit exchange across 31 characters.

Swap Flag: After each swap, dl was set to 1 signaling a swap occurred; the sorting continued.

Completion: When no swaps occur in one full iteration, the array is fully sorted.

Bubble Sort Algorithm (Conceptual):

void bubble_sort(event *events, int len) {
    int swapped;
    do {
        swapped = 0;
        for (int i = 0; i < len - 1; i++) {
            if (events[i].valid < events[i + 1].valid) {
                // swap
            } else if (events[i].valid == events[i + 1].valid) {
                // compare year
            }
            // further comparisons on month, day, and name
        }
    } while (swapped);
}
Base64 Encoding

Objective: Convert an input string into Base64 format by processing groups of 3 bytes into 4 Base64 characters.

Registers:

ebx: length of input string (n)

esi: pointer to input string

edi: pointer to output string

edx: address to store output length

eax and ecx were initialized to zero; eax serves as a counter for output length, while ecx iterates through input bytes.

Grouping and Combining 3 Bytes:

The algorithm processes input in 3-byte groups (24 bits).

Each byte is loaded into al (8 bits) and shifted left appropriately using bit shifts of 8 bits, combining them into a 24-bit value stored in eax.

Extracting 6-bit Chunks:
Using bit shifting and masking, each group of 6 bits is extracted:

First 6 bits: shift right by 18 bits (shr ebx, 18)

Next 6 bits: shift right by 12 bits

Next 6 bits: shift right by 6 bits

Final 6 bits: mask with 0x3F

Mapping to Base64 Alphabet:
Each 6-bit group is used as an index into the Base64 alphabet to obtain the corresponding character.

Storing Output:
All four Base64 characters obtained from the 24 bits are stored in the output buffer at edi, incrementing edi after each character.

Pointer Adjustment:
After processing each 3-byte group, ecx is incremented by 3 to move to the next input group, and edi by 4 for the next output position.

Sudoku Validation

Goal: Validate that each row, column, and 3x3 box contains only valid values (1 to 9) with no duplicates.

Auxiliary Array:
An auxiliary array digit_exists of length 10 (index 0-9) tracks digits encountered within a row, column, or box. It is reset to 0 at the start of each check. If a duplicate digit is found, the function returns 2 indicating invalid; otherwise, it returns 1 for valid.

Check Row:
Calculate start of the row by multiplying the row index by 9, as each row contains 9 cells. Use eax to compute this and esi to point to the start of the row. Loop through 9 cells (ebx controls the loop). Check that each value is between 1 and 9 and that no duplicates exist. Return 2 if invalid or duplicate found; else return 1.

Check Column:
Similar process as row checking. Calculate start position of the column. Iterate through each cell in the column, adding row * 9 offset to reach the correct position. Use digit_exists to avoid duplicates. Return 2 if invalid or duplicate, otherwise 1.

Check 3x3 Box:
More complex due to calculating the correct 3x3 box start position on a 9x9 grid. Each box has 9 cells. Start position calculation: horizontal band: box / 3; vertical band: box % 3. Formula applied on esi pointer: (box / 3) * 27 + (box % 3) * 3 to point to box start. Loop through each of the 9 cells in the box. Use digit_exists to detect duplicates and verify values between 1 and 9. Return 2 if invalid or duplicate found, else 1.

Technical Details:

esi stores the pointer to the Sudoku board.

edi accesses the digit_exists array used to track seen digits.

ebx controls the iteration loops.

ecx counts iterations.

Return Values: 1 if row, column, or box is valid; 2 if invalid or duplicates are found.
